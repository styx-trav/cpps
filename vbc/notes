okay heres the deal :: i don't really get the binary distribution just yet, so lets write it out and see if we can do something

6+9*5+3*2


so when we read this (no par) ::::
	first node (l, r : NULL, NULL) = (6);
	second node (l, r : (6), NULL) = (ADD);
	third node == ADD->r (l, r : NULL, NULL);

okay, so i guess we replace the node within ? like instead of going up to down or down to up we just shift nodes around ::
from (6), we get (6, ADD, NULL), then (6, ADD, 9), then (6, ADD, (9, MULTI, NULL)), then (6, ADD, (9, MULTI, 5))

and then, ((6, ADD, (9, MULTI, 5)), ADD, NULL), and then ((6, ADD, (9, MULTI, 5)), ADD, 3), and then ((6, ADD, (9, MULTI, 5)), ADD, (3, MUTLI, NULL)), and then ((6, ADD, (9, MULTI, 5)), ADD, (3, MULTI, 2))
		

into nodes :: in order l->r

(6), (ADD), (9), (MULTI), (5), (ADD), (3), (MULTI), (2)

in order priority of reading;
			  (ADD)
                  (ADD)           (MULTI)
           (6)        (MULTI)    (3)    (2)
                    (9)     (5)          

and into my switch case i get ::
0: return (l + r) = 51 + 6 = 57
0l: return (l + r) = 51
0ll: return 6
0lr: return (l * r) = 45
0lrl: return 9
0lrr: return 5
0r: return (l * r) = 6
0rl: return 3
0rr: return 2

yessssssssssssssss we got it, now just to figure out the parentheses (in the bus !)

parentheses options ::

we need different heads, i think ? or a recursive function or sthg;
like the same function we already have, and then send the head to a in-parentheses function to do all the priority work over there, and then i get that head back to put on my left/right item

testing testing

6+9*(5+3)*2

(6)
(6, ADD, NULL)
(6, ADD, 9)
(6, ADD, (9, MULTI, NULL))
(6, ADD, (9, MULTI, make_chain()))
(6, ADD, (9, MULTI, 5))
(6, ADD, (9, MULTI, (5, ADD, NULL)))
(6, ADD, (9, MULTI, (5, ADD, 3)))
(6, ADD, (9, MULTI, (5, ADD, 3)))
(6, ADD, (9, MULTI, ((5, ADD, 3), MULTI, NULL))
(6, ADD, (9, MULTI, ((5, ADD, 3), MULTI, 2))

8*2*9+6 = 

reality ::
(6, ADD, (9, MULTI, ((5, ADD, 3), MULTI, 2)) !=
(6, ADD, (9, MULTI, (5, ADD, (3, MULTI, 2)))


