strings get a bunch of functions attached, beyond .length and .begin or .end
including adjacent functions like &istream& getline(istream& is, string& str, char delim);
which can be used with (std::cin, str) if needed, though std::cin.getline(str, size) works fine
	//wonder if the regular getline could work like that, too
<fstream> for file streams
class ofstream/ifstream/fstream (out, in, both) and its member funcs
void open(char *file, ios::openmode mode) ios::in for reading, ios::out for writing, ios::app for append, etc.


getline, then find content in string (specifically the find function, which returns size_t pos)
write before string1, then string2, then after string1, on repeat until end of line
repeat

or ? word by word would work, too. a loop that takes the word, checks it, and on an if basis a)is word, write replacement into the new file, b)is not word, just write it as is into the new file.

no, i was right, we're doing the getline method. find the position of the word in the string, write everything before into the new file, skip the word, repeat. maybe use a throwaway string to bridge over ? like, switch the original line with the original line + end of the position at the length of the word1 string
im sure there's a way to out stream up to a specific number position-wise, and by then ill have moved on to the next option

ok, everything works great. used substr to extract the part of the string i wanted, skip ahead and get the next sample to check. now a couple of file protections and we should be good !

protections on, added the input, should be good - just needs a makefile
